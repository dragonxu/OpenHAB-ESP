#include "OpenHAB.h"
// Following two variables are defined in main.cpp
extern uint8_t itemCount, groupCount;

#ifndef OPENHAB_GEN_CONFIG
	extern OpenHab::Item items[];
	extern OpenHab::ItemState itemStates[];
	extern OpenHab::Group groups[];
#endif

//OpenHab::OpenHab(Item *items, unsigned short itemCount, const int port) : 
OpenHab::OpenHab(const int port) : 
	_server(port),
	_SSEserver(port + 1),
	_port(port),
	_print(_server.client()),
	_itemList(nullptr),
	//_items(items),
	//_itemCount(0),
	_groupList(nullptr)
	{}


/*
JsonVariant OpenHab::cloneInPlace(JsonBuffer& jb, JsonVariant prototype) {
	if (prototype.is<JsonObject>()) {
		const JsonObject& protoObj = prototype;
		JsonObject& newObj = jb.createObject();
		for (const auto& kvp : protoObj) {
			newObj[kvp.key] = cloneInPlace(jb, kvp.value);
			if (!strcmp(kvp.key, "leaf") && (kvp.value.as<bool>())) break;
		}
		return newObj;
	}
	if (prototype.is<JsonArray>()) {
		const JsonArray& protoArr = prototype;
		JsonArray& newArr = jb.createArray();
		for (const auto& elem : protoArr) newArr.add(cloneInPlace(jb, elem));
		return newArr;
	}
	if (prototype.is<char*>()) return prototype.as<char*>(); //jb.strdup(prototype.as<char*>());
	return prototype;
}
 */

/* 
JsonVariant OpenHab::getNestedMember(const JsonVariant prototype, const char *key) {
	DbgPrintln(F("getNestedMember: key: "), key);
	if (prototype.is<JsonObject>()) {
		const JsonObject& obj = prototype;
		for (const JsonPair pair : obj) {
			DbgPrintln("key:", pair.key().c_str());
			if (!strcmp(pair.key().c_str(), key)) {
				DbgPrintln("Found key:", key);
				return pair.value();
			}
			getNestedMember(pair.value().as<JsonObject>(), key);
			for (auto arr : pair.value().as<JsonArray>()) {
				getNestedMember(arr.as<JsonVariant>(), key); }
		}
	} else if (prototype.is<JsonArray>()) {
		const JsonArray& arr = prototype;
		for (const auto& elem : arr) getNestedMember(elem.as<JsonVariant>(), key); //, parent);
	}
	return DynamicJsonDocument(0).as<JsonVariant>();
}
*/

#ifndef OPENHAB_GEN_CONFIG
static void printTm(const __FlashStringHelper *s, const tm* tm) {
  Serial.print(s);
  PTM(isdst); PTM(yday); PTM(wday);
  PTM(year);  PTM(mon);  PTM(mday);
  PTM(hour);  PTM(min);  PTM(sec);
}

/*
void OpenHab::SSESocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
//void OpenHab::webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
    switch(type) {
        case WStype_DISCONNECTED:
            Serial.printf("[%u] Disconnected!\n", num);
            break;
        case WStype_CONNECTED:
            {
                IPAddress ip = _SSEserver.remoteIP(num);
                Serial.printf("[%u] Connected from %d.%d.%d.%d url: %s\n", num, ip[0], ip[1], ip[2], ip[3], payload);
				
				// send message to client
				_SSEserver.sendTXT(num, "Connected");
            }
            break;
        case WStype_TEXT:
            Serial.printf("[%u] get Text: %s\n", num, payload);

            // send message to client
            // webSocket.sendTXT(num, "message here");

            // send data to all connected clients
            // webSocket.broadcastTXT("message here");
            break;
        case WStype_BIN:
            Serial.printf("[%u] get binary length: %u\n", num, length);
            //hexdump(payload, length);

            // send message to client
            // webSocket.sendBIN(num, payload, length);
            break;
		default: break;
    }

}
 */

void OpenHab::SSEHandler() {
	DbgPrintRequest(_SSEserver, F("SSEHandler"));
	WiFiClient client = _SSEserver.client();
	String uuidStr =  _SSEserver.uri().substring(sizeof("/rest/sitemaps/events/") - 1);
	DbgPrintln(F("uuidstring: "), uuidStr);
	Subscription *subscription = _subscription;
	while (subscription) { // Locate subscription with uuid
		if ((subscription->uuidStr != uuidStr) || (subscription->clientIP != uint32_t(_SSEserver.client().remoteIP()))) {
			DbgPrintln(F("SSEHandler: no matching uuid and IP"), IPAddress(subscription->clientIP).toString());
			subscription = subscription->next;
		} else break;
	}
	if (!subscription) {
		return handleNotFound(_SSEserver); // no subscription matches both IP and UUID 
	}  // At this point we have a matching subscription

	subscription->client = client; // update client
	String sitemap = _SSEserver.arg(PSTR("sitemap"));
	String pageid = _SSEserver.arg(PSTR("pageid"));
	_SSEserver.setContentLength(CONTENT_LENGTH_UNKNOWN);
	_SSEserver.sendContent_P(PSTR("HTTP/1.1 200 OK\r\nContent-Type: text/event-stream;\r\nConnection: keep-alive\r\nCache-Control: no-cache\r\nAccess-Control-Allow-Origin: *\r\n\r\n"));
	client.printf_P(PSTR("event: event\ndata: { \"TYPE\":\"ALIVE\",\"sitemapName\":\"%s\",\"pageId\":\"%s\"}\n"), sitemap.c_str(), pageid.c_str());
	client.flush();
	auto keepAliveBind = std::bind(static_cast<void(OpenHab::*)(WiFiClient, String, String)>(&OpenHab::SSEKeepAlive), this, client, sitemap, pageid);
	_SSEKeepAliveTimer.attach(60.0, keepAliveBind);  // Refresh time every minute (could be optimized in the future)
}

//void OpenHab::SSEKeepAlive(const char *sitemap, const char *pageId) {
void OpenHab::SSEKeepAlive(WiFiClient client, String sitemap, String pageid) {
	if (client.connected()) {
		//DbgPrintln(F("Client is still connected - pageId: "), pageId);
		client.printf_P(PSTR("event: event\ndata: { \"TYPE\":\"ALIVE\",\"sitemapName\":\"%s\",\"pageId\":\"%s\"}\n"), sitemap.c_str(), pageid.c_str());
		client.flush();
	}
}

void OpenHab::SSEPageUpdate(JsonVariant obj) {
	DbgPrintln(F("serverSentEvent: "));
	Subscription *subscription = _subscription;
	WiFiClient client;
	while (subscription) {
		client = subscription->client;
		DbgPrintln(F(" - client IP: "), IPAddress(subscription->clientIP).toString());
		if (client.connected()) {
			DbgPrintln(F("Client is still connected"));
			client.printf_P(PSTR("event: event\ndata: "));
			serializeJson(obj, client);
			serializeJson(obj, Serial);			
			client.println();
			client.flush();
		};
		subscription = subscription->next;
	}
}

/* 
void OpenHab::handleSSEdata(WiFiClient client) {
  if (client) {
    serverSentEventHeader(client);
    while (client.connected()) {
      serverSentEvent(client);
      delay(16); // round about 60 messages per second
    }

    // give the web browser time to receive the data
    delay(1);
    // close the connection:
    client.stop();
    Serial.println("client disconnected");
  }
}
*/
const char *OpenHab::functionOR(uint8_t groupIdx, uint8_t itemIdx, int *numItems) {
	int count = 0;
	//ItemList *itemList = group->items;
	DbgPrintln(F("functionOR"));
	ItemState &itemState = itemStates[itemIdx];
	JsonObject f = itemState.obj[F("function")];
	JsonArray fparams = f[F("params")];
	const char *fvalue = fparams[0];
	Group &group = groups[groupIdx];
	DbgPrint(F(" - value: "), fvalue);
	DbgPrintln(F(" - itemCount: "), group.itemCount);
	uint8_t *groupItems = group.items;
	for (uint8_t n = 0; n < group.itemCount; n++) {
		uint8_t itemIdx = groupItems[n];
		char *state = itemStates[itemIdx].state;
		DbgPrint(F(" - item name: "), items[itemIdx].name);	DbgPrintln(F(" - item state: "), state);		
		if (state && strcmp(fvalue, state) == 0) count++;
	}
	DbgPrintln(F(" - final count: "), count);
	//DbgPrintf("functionOR - state address: %p\n", (void *)fvalue);
	*numItems = count;
	return (char *)(count > 0) ? fvalue : fparams[1].as<const char *>();
}

FORCE_INLINE float OpenHab::functionAVG(uint8_t *groupItems, uint8_t count) {
	DbgPrintln(F("functionAVG"));
	float avg = 0;
	for (uint8_t n = 0; n < count; n++)
		avg += strtof(items[groupItems[n]].state, nullptr);
	return (count) ? avg / count : (float)0.0;
}

static size_t snprintftime(char *state, char *label, const char *labelFormat, int count = 0) {
	static char buf[40];    
	static tm tmb;
	strptime(state, "%Y-%m-%dT%H:%M:%S", &tmb);
	//DbgPrint(F(" - format: "), labelFormat);
	return (count == 0) ? strftime(buf, 40, labelFormat, &tmb) : strftime(label, count, labelFormat, &tmb);
}		
FORCE_INLINE static size_t snprintftime(float state, char *label, const char *labelFormat, int count = 0) { return 0; }
FORCE_INLINE static size_t snprintftime(int state, char *label, const char *labelFormat, int count = 0) { return 0; }
OpenHab::Item getItem(uint8_t itemIdx) {
	static OpenHab::Item item;
	memcpy_P(&item, &items[itemIdx], sizeof(OpenHab::Item));
	return item;
}

// Set label of all references to given item
void setReferenceLabel (const OpenHab::ItemReference *references, uint8_t count, const char *label) {
	for (uint8_t n = 0; n < count; n++) {
		//JsonObject labelObj = references[n].widgetObj[F("label")];
		references[n].widgetObj[F("label")] = label;
		//char *lbl = (char *)(labelObj.as<const char *>());  //pointer to last formatted label or nullptr initially
		//lbl = (char *) realloc((void *)lbl, strlen(label));		//labelObj.set((const char *)label);
		//labelObj.set((const char *)label); // write back pointer to updated label
		//references[n].obj[F("state")] = (const char *) state;
		//JsonObject stateObj = references[n].obj[F("state")];
		//stateObj.set((const char *)state);
	}	
}

template <typename T> static void sprf(T state, uint8_t itemIdx) {
	//static char _oldLabel[128];
	DbgPrint(F(" --> sprf "));	
	OpenHab::Item item = getItem(itemIdx);			// Create a Item copy from flash
	OpenHab::ItemState &itemState = itemStates[itemIdx];
	const char *labelFormat = item.labelFormat; // formatted label
	JsonVariant labelObj = itemState.widgetObj[F("label")];
	char *label = (char *)(labelObj.as<const char *>());  //pointer to last formatted label or nullptr initially
	//size_t len = (label) ? strlen(label) : 0;
	//if (len == 0) label = nullptr;
	//if (len) strncpy(_oldLabel, label, len); 
	//_oldLabel[len] = 0; // save a copy of old label, assuming < 128 characters
	DbgPrint(F(" - oldLabel: "), label);
	size_t count = (item.type == ItemDateTime) ? snprintftime(state, label, labelFormat) : snprintf(NULL, 0, labelFormat, state);
	label = (char *) realloc((void *)label, ++count);
	(item.type == ItemDateTime) ? snprintftime(state, label, labelFormat, count) : sprintf(label, labelFormat, state);
	labelObj.set((const char *)label); // write back pointer to updated label
	if (item.referenceCount > 0) 
		setReferenceLabel(itemState.references, item.referenceCount, label);
	DbgPrintln(F(" - newLabel: "), label);
}

void OpenHab::updateLabel(uint8_t itemIdx, char *state, ItemType type, int numItems) {
	DbgPrint(F("updateLabel"));	DbgPrint(F(" - type: "), ItemTypeStr[type]);
	DbgPrint(F(" - numItems: "), numItems);	DbgPrint(F(" - state: "), state);
	switch (type) {
		case ItemContact:
		case ItemString:
		case ItemSwitch:
		case ItemDateTime:
			sprf(state, itemIdx); break;
		case ItemNumber:
			sprf(strtof((state) ? state : "0", NULL), itemIdx); break; // (float)atof(item->state)
		case ItemGroup:
		case ItemDimmer:
			(numItems == -1) ? sprf(atoi(state), itemIdx) : sprf(numItems, itemIdx); break;
		default:;
	}
}

FORCE_INLINE void OpenHab::setGroupState(const char *groupName) {
	DbgPrintln(F("setGroupState: "), groupName);
	uint8_t itemIdx = getItemIdx(groupName);
	if (! isValidItemIndex(itemIdx)) return;	// Invalid item
	Item item = getItem(itemIdx);		// Create a Item copy from flash
	if (item.type != ItemGroup) return; // Item is not a group
	Group &group = groups[item.groupIdx];
	if (group.function == FunctionAVG) {
		setState(itemIdx, functionAVG(group.items, group.itemCount), false);
		updateLabel(itemIdx, itemStates[itemIdx].state, item.type);
	} else if (group.function == FunctionOR) {
		int count;
		setState(itemIdx, functionOR(item.groupIdx, itemIdx, &count), false);
		updateLabel(itemIdx, itemStates[itemIdx].state, item.type, count);
	}
}

// Function to set and eventually propagate (e.g. label, group state) the state of an item 
void OpenHab::setState(uint8_t itemIdx, const char *state, bool updateGroup) {
	static char prevState[128], intState[4];
	auto setCurrentDateTime = [&](void *p) {
		static bool first = true;
		time_t now = time(nullptr); // Time since epoch
    	const tm* tm = localtime(&now); // Converted to localtime
		//printTm(F(" - currentDataTime: "), tm);
		strftime ((char *) p, 24 ,"%FT%T", tm);  // Converted to an ISO date string
		if (!first) return;	// Register a call back every minute, but only on the first invocation
		first = false;
		auto setStateBind = std::bind(static_cast<void(OpenHab::*)(uint8_t, const char*, bool)>(&OpenHab::setState), this, itemIdx, state, true);
		_currentDateTimer.attach(60.0, setStateBind);  // Refresh time every minute (could be optimized in the future)
	};

	DbgPrintln(F("setState: "), (state) ? state : "NULL");
	if (!state) return;							// NULL states can crash setState
	
	// We have a valid state
	ItemState itemState = itemStates[itemIdx];	// Get current (previous) state
	Item item = getItem(itemIdx);				// Get Item copy from flash

	size_t len = (itemState.state) ? strlen(itemState.state) + 1: 0;  // Length of old state
	if (len) strncpy(prevState, itemState.state, min(len, (size_t)127));
	DbgPrint(F(" - previous state: "), prevState);

	if (item.type == ItemRollerShutter) {
		size_t value = atoi(prevState);
		if (strcmp_P(state, "UP") == 0) value = min(value + 10, (size_t)100);
		else if (strcmp_P(state, "DOWN") == 0) value = max(value - 10,  (size_t)0);
		else value = atoi(state);
		sprintf_P(intState, PSTR("%d"), value);
		state = intState;
	}

	bool isCurrentDateTime = ((item.type == ItemDateTime) && !strncmp_P(item.name, PSTR("Current"), 7)); // item name reflecting current Date/Time?
	len = (isCurrentDateTime) ? 24 : strlen(state) + 1;
	void *p = realloc((void *) itemState.state, len);  // New state might require more space
	if (isCurrentDateTime) // This is a request to supply the current date and time
		setCurrentDateTime(p);
	else memcpy(p, state, len);  // Replicate the new state
	DbgPrint(" - new state: ", (char *) p);
	itemState.state = (char *)p;
	itemState.obj[F("state")] = (const char *) p;

	const ItemReference *references = itemState.references;
	for (uint8_t n = 0; n < item.referenceCount; n++)
		references[n].obj[F("state")] = (const char *) p;

	DbgPrintln(" - updateGroup: ", (updateGroup) ? "true" : "false");
	//if (isCurrentDateTime) serverSentEvent(item);
	if (!updateGroup) return;

	/*
	if (item.type == ItemGroup) {
		Group &group = groups[item.groupIdx];
		uint8_t *groupItems = group.items;
		for (uint8_t n = 0; n < group.itemCount; n++)
			setState(groupItems[n], state, false);
	} else {  // if item is part of a (number of) group(s), update their states accordingly
	*/
		JsonArray groupNames = itemState.obj[F("groupNames")];
		for (JsonVariant groupName : groupNames)
			setGroupState(groupName);
	//}
	if (item.labelFormat) updateLabel(itemIdx, (char *)p, item.type);  // finally update the parent label reflecting the new state
}

// Function to set and eventually propagate (e.g. label, group state) the state of an item with numeric state (e.g. type Number)
FORCE_INLINE void OpenHab::setState(uint8_t itemIdx, float f, uint8 precision, bool updateGroup) {
    char fs[14];  // Used to convert float to string
	DbgPrintln("setState float: ", f);
	setState(itemIdx, dtostrf(f, precision + 2, precision, fs), updateGroup);
}
/*
FORCE_INLINE void OpenHab::setState(uint8_t itemIdx, int i, bool updateGroup) {
	DbgPrintln("setState int: ", i);
	setState(itemIdx, (const char *) itoa(i), updateGroup);
}
*/
FORCE_INLINE bool isFormatted(const char* label) {
	char curr, next = *label++;
	while ((curr = next) != '\0') {
		next = *label++;
		if ((curr == '%') && (next != '%')) return true;
	}
	return false;
}

uint8_t OpenHab::getItemIdx (const char *name) {
	uint8_t middle, first = 0, last = itemCount;
	do {
		middle = (first + last) >> 1;
		int cmp = strcmp(items[middle].name, name);
		if (cmp == 0) return middle;
		else if (cmp < 0) first = middle + 1;
		else last = middle - 1;
	} while (first <= last);
	return (uint8_t) 255;		
};

void OpenHab::setState(const char *itemName, const char *state, bool updateGroup) {\
	uint8_t itemIdx = getItemIdx(itemName);
	if (isValidItemIndex(itemIdx))
		return setState(itemIdx, state, updateGroup);
	Serial.printf_P(PSTR("PANIC! Invalid item %s\n"), itemName);
}

// Adds an Item to the itemList and set its initial state as well as any label deduced from that state
// If the item is a group, add the group
// If the itme is member of a group, add the group when not yet existing and include the item as member of the group
FORCE_INLINE void OpenHab::updateItem(const JsonVariant itemObj, const JsonVariant widgetObj, const char* pageId) {
	const char *name = itemObj[F("name")];
	DbgPrint(F("update item "), name); 
	
	uint8_t itemIdx = getItemIdx(name);
	if (! isValidItemIndex(itemIdx)) {
		Serial.printf_P(PSTR("PANIC: item %s not found!!\n"), name);
		return;
	}
	// At this point we have an item, but we need to update it
	Item item = getItem(itemIdx);			// Create a Item copy from flash
	ItemType itemType = item.type;
	ItemState &itemState = itemStates[itemIdx];
	const char* state = item.state;			// Get initial state from flash
	itemState.state = (state) ? strdup(state) : nullptr;		// and duplicate (no need for _P)
	itemState.pageId = pageId;
	JsonVariant labelObj = widgetObj[F("label")];
	const char *label = labelObj; 
	if (item.labelFormat) labelObj.set(nullptr);		// Initialize formatted label to nullstr
	DbgPrint(F(" - type: "), itemType);	DbgPrint(F(" - state: "), item.state); DbgPrint(F(" - label: "), label);
	DbgPrint(F(" - pageid: "), pageId);

	uint8_t refCount = ++item.referenceCount;
	if (refCount > 0) {
		if (!itemState.references) {
			itemState.references = new ItemReference[refCount];
			goto setObject;
		} else {
			const ItemReference *references = itemState.references;
			for (uint8_t n = 0; n < refCount; n++)
				if (!references[n].obj) { 	// first empty entry
					DbgPrintln(F(" - item reference slot: "), n);
					const ItemReference ref = { itemObj, widgetObj };
					memcpy((void *)&references[--refCount], (void *)&ref, sizeof(ItemReference));
				}
		}
		return;
	}
setObject:
	DbgPrintln(F(""));	//item.link = itemObj[F("link")];
	itemState.obj = itemObj;
	itemState.widgetObj = widgetObj;
	
	//if (item.labelFormat != nullptr)	// Label contains formatting
	//	widgetObj[F("label")] = nullptr;

	//if (state) setState(itemIdx, state, false); // First pass setState
	//DbgPrintln(" - back from setState");
}

void OpenHab::registerLinkHandlers(const JsonObject obj, const char *pageId, Sitemap *sitemap) {
	for (const JsonPair pair : obj) {
		const char *key = pair.key().c_str();
		if (!strcmp_P(key, PSTR("linkedPage")) || !strcmp_P(key, PSTR("homepage"))) { // Page
			JsonObject pageObj = pair.value().as<JsonObject>();
			pageId = pageObj[F("id")];
			DbgPrintln(F("page: "), pageId);
		} else if (!strcmp_P(key, PSTR("link"))) { // Sitemap
			const char* link = pair.value().as<const char*>(); //pageObj[F("link")];
			if (!strncmp_P(&link[6], PSTR("site"), 4)) {
				DbgPrintln(F("sitemap: "), link);
				sitemap->pageList = new Page {link + sizeof("/rest/sitemaps"), (JsonVariant) obj, sitemap->pageList};
			}
		} else if (!strcmp_P(key, PSTR("item"))) // Items
			updateItem(pair.value().as<JsonObject>(), obj, pageId);

		registerLinkHandlers(pair.value().as<JsonObject>(), pageId, sitemap); //, pair.key);
		for (auto arr : pair.value().as<JsonArray>()) registerLinkHandlers(arr.as<JsonObject>(), pageId, sitemap); //, pair.key);
	}
}
/*
void OpenHab::registerLinkHandlers(const JsonVariant prototype, Sitemap *sitemap) {
	if (prototype.is<JsonObject>()) {
		const JsonObject& obj = prototype;
		for (const JsonPair pair : obj) {
			const char *key = pair.key().c_str();
			if (!strcmp_P(key, PSTR("link"))) { // Sitemap
				const char* link = pair.value().as<char*>();
				if (!strncmp_P(&link[6], PSTR("site"), 4)) {
					DbgPrintln(F("sitemap: "), link);
					sitemap->pageList = new Page {link + sizeof("/rest/sitemaps"), (JsonVariant) obj, sitemap->pageList}; 
          			//_server.on(STRREF(link), std::bind(&OpenHab::handleSitemap, this, (JsonVariant) obj));
				}
			} else if (!strcmp_P(key, PSTR("item"))) // Items
				updateItem(pair.value().as<JsonObject>(), obj, "");
    		
			registerLinkHandlers(pair.value().as<JsonObject>(), sitemap); //, pair.key);
			for (auto arr : pair.value().as<JsonArray>()) {
				registerLinkHandlers(arr.as<JsonVariant>(), sitemap); //, pair.key);
			}
		}
	} else if (prototype.is<JsonArray>()) {
		const JsonArray& arr = prototype;
		for (const auto& elem : arr) registerLinkHandlers(elem.as<JsonVariant>(), sitemap); //, parent);
	}
}
*/
#endif

//DynamicJsonDocument OpenHab::getJsonDocFromFile(File f) {
DynamicJsonDocument OpenHab::getJsonDocFromFile(String fileName) {
	DbgPrintln(F("OpenHab::getJsonDocFromFile: file name: "), fileName);
	DbgPrintln(F("free heap memory @entry: "), ESP.getFreeHeap());
	File f = SPIFFS.open(fileName, "r");
	DynamicJsonDocument doc(ESP.getFreeHeap() - 4096);
	DbgPrintln(F(" - allocated: "), doc.capacity());
	//DbgPrintln(F("after allocation of Json doc: "));
	DeserializationError err = deserializeJson(doc, f, DeserializationOption::NestingLimit(20));
	//deserializeJson(doc, f, DeserializationOption::NestingLimit(20));
	DbgPrintln(F(" - deserializeJson: "), doc.memoryUsage());
	if (err == DeserializationError::Ok) doc.shrinkToFit();
	else DbgPrintln(F("deserializeJson failed "), err.c_str());
	f.close();
	DbgPrintln(F("free heap memory @exit: "), ESP.getFreeHeap());
	return doc;
}

bool OpenHab::Init(const char *ssid, const char *APssid, const char* passphrase, const char*allowedMAC[],
	const char *local_ip, const char *gateway, const char *subnet) {
 	DbgPrintln(F("OpenHab::InitServer"));
	IPAddress espIP;

	// Setup WiFi network
 	WiFi.persistent(false);	// Disables storing the SSID and pasword by SDK
	WiFi.setSleepMode(WIFI_LIGHT_SLEEP); //WIFI_NONE_SLEEP);
	WiFi.setOutputPower(17);        // 10dBm == 10mW, 14dBm = 25mW, 17dBm = 50mW, 20dBm = 100mW
	WiFi.setAutoConnect(false);	// Disables the auto connect of the SDK
  	WiFi.softAPdisconnect(true);
	WiFi.enableAP(false);
  	WiFi.mode(WIFI_STA);
	WiFi.disconnect();
	WiFi.hostname(APssid);
	delay(1000); 

	/*// Don't save WiFi configuration in flash - optional
	  int32_t  channel (void)
	  WiFiSleepType_t  getSleepMode ()
	  bool  setPhyMode (WiFiPhyMode_t mode)
	  WiFiPhyMode_t  getPhyMode ()
	  void  setOutputPower (float dBm)
	  WiFiMode_t  getMode ()
	  bool  forceSleepBegin (uint32 sleepUs = 0)
	  bool  forceSleepWake ()
	  int  hostByName (const char *aHostname, IPAddress & aResult)

	DbgPrintln("Scan start ... ");
  	int n = WiFi.scanNetworks();
  	DbgPrintln("network(s) found: ", n);
  	for (int i = 0; i < n; i++) DbgPrintln("-- ", WiFi.SSID(i));
	*/	
	int len = strlen(passphrase);
	char *_passphrase = strdup(passphrase);
	for (int i = 0, j = 1; i < len; i += 2, j += 2) {
		std::swap(_passphrase[i], _passphrase[j]);
	}
	char *pwdDecoded = (char *)calloc(len + 1, sizeof(char));
	base64_decode_chars(_passphrase, len - 1, pwdDecoded);
	delete _passphrase;
	DbgPrintln(F("passcode: "), pwdDecoded);

	if (ssid) { // We have an SSID, connect to this AP
		if (!WiFi.enableSTA(true)) { //enable STA failed
			DbgPrintln(F("could not enable station mode"));
		} else { 
			wifi_station_set_hostname(APssid);
			WiFi.begin(ssid, pwdDecoded);
			//while (WiFi.status() != WL_CONNECTED) delay(500);
			if (WiFi.waitForConnectResult() == WL_CONNECTED) {
				DbgPrint(F("Connected to AP "), ssid);
				DbgPrint(F(" with MAC:"), WiFi.macAddress());
				DbgPrintln(F("and name:"), WiFi.hostname());
				_espIP = WiFi.localIP();
				configTime(TZ_Europe_Brussels, "0.be.pool.ntp.org", "1.be.pool.ntp.org"); // If on AP, get time
				//configTime(TZ_Etc_GMTm7, "pool.ntp.org"); // If on AP, get time
				int count = 100;
				while((time(nullptr) <= 100000) && count--) delay(100);
				if (count < 0) Serial.println(PSTR("Time server not reachable"));
				else Serial.println(F("Time from time server"));
				goto out;
			}
		}
	}
	// Fallback to SoftAP if no connection to AP
	DbgPrintln(F("Falling back to soft AP due to failed connection to AP "), ssid);
  	WiFi.mode(WIFI_AP);
  	WiFi.enableSTA(false);
	WiFi.disconnect(true);
	if (APssid) { // We  stat
		if (!WiFi.enableAP(true)) { //enabling of Soft AP failed
			DbgPrintln(F("could not create Access Point"));
			return false;
		}
		IPAddress local_IP(192,168,4,1);
    	IPAddress gateway(192,168,4,1);
    	IPAddress subnet(255,255,255,0);

		wifi_station_set_hostname(APssid);
		if (!WiFi.softAPConfig(local_IP, gateway, subnet))
		DbgPrintln(F("could not configure Access Point"));
		WiFi.softAP(APssid, pwdDecoded, 13, false, 4);
    	MDNS.begin(APssid);
		wifi_station_set_hostname(APssid);
    	WiFi.hostname(APssid);
		DbgPrintln(F("Soft AP name"), WiFi.hostname());
		if (local_ip) //Set local AP IP
			WiFi.softAPConfig(local_IP, gateway, subnet);
		_espIP = WiFi.softAPIP();
	}
out:
	delete pwdDecoded;
	DbgPrintln(F("IP address: "), _espIP.toString());
	//_currentDateTimer.attach(60.0, std::bind(&OpenHab::updateTime, this));
	delay(100);
	wifi_set_event_handler_cb(wifiEventHandler);

	SPIFFS.begin();
#ifndef OPENHAB_GEN_CONFIG
	DbgPrintln(F("Loading sitemap"));
	_sitemapList = GetSitemapsFromFS();
	
	DbgPrintln(F("Initializing states and labels"));	// Second pass set state
	for(uint8_t n = 0; n < itemCount; n++) {
		DbgPrint(F("init state: "), n);
		DbgPrintln(F(" - name : "), items[n].name);
		setState(n, itemStates[n].state);
	}
#endif
	DbgPrintln(F("Exit OpenHab::InitServer"));
	return true;
}

void OpenHab::HandleClient() {
	_server.handleClient();
	_SSEserver.handleClient();
}

#ifdef OPENHAB_GEN_CONFIG
FORCE_INLINE static void convDateTimeJavaToC(char *dateTime) {
	String dateTimeStr = dateTime;
	dateTimeStr.replace("1$t", "");
	strncpy(dateTime, dateTimeStr.c_str(), dateTimeStr.length() + 1);
	DbgPrintln(F("convDateTimeJavaToC: "), dateTime);
}

const char *genFormattedLabel(String label, const char *pattern, const char* state) {
	String formattedLabel;
	formattedLabel = label.substring(0, label.indexOf("[") + 1);
	formattedLabel += pattern;
	formattedLabel += label.substring(label.indexOf("]"));
	if (formattedLabel.indexOf(F("%unit%"))) {
		String s = state;
		String unit = s.substring(s.indexOf(" ") + 1);
		formattedLabel.replace("%unit%", unit);
	}
	DbgPrintln(F(" - new label: "), formattedLabel.c_str());
	return strdup(formattedLabel.c_str());
}

FORCE_INLINE OpenHab::Group *OpenHab::getGroup(const char *name) {
	Group *group = _groupList;
	while (group && (strcmp(group->name, name)))
		group = group->next;
	return group;
}

FORCE_INLINE OpenHab::Item *OpenHab::getItem(const char *name) {
	Item *item = _itemList;
	while (item && (strcmp(item->name, name)))
		item = item->next;
	return item;
}

// type == ItemNone: we just have a group name and item is a group member
// type == ItemGroup: we have a true group, check groupType for a group with dynamic label & state 
OpenHab::Group *OpenHab::newGroup(const char *groupName, Item *item, JsonObject obj, ItemType type) {
	GroupFunction groupFunction = FunctionNone;
	//JsonObject obj = item->obj;
	JsonVariant groupTypeVariant = obj[F("groupType")];  
	ItemType groupType = (groupTypeVariant.isNull()) ? ItemNull : getItemType(groupTypeVariant);
	DbgPrint(F("adding group with name: "), groupName);
	DbgPrintln(F(" - grouptype: "), groupType);
	
	if (type == ItemGroup) { // item refers to a true group item
		JsonObject groupFunctionObj = obj[F("function")];  // if it has a function, it has a dynamic label & state
		if (!groupFunctionObj.isNull()) {
			const char *groupFunctionStr = groupFunctionObj[F("name")];
			if (!strcmp_P(groupFunctionStr, PSTR("AVG")))
				groupFunction = FunctionAVG;
			else if (!strcmp_P(groupFunctionStr, PSTR("OR"))) groupFunction = FunctionOR;
		}
		DbgPrintln(F(" - groupfunction: "), groupFunction);
	}		

	if (Group *group = getGroup(groupName)) { // we might already have a group with this name but without group leader
		if (groupType != ItemNull) { // group with dynamic label/state found
			DbgPrintln(F("Group leader found: "), groupName);
			group->type = groupType; // update type		
			group->function = groupFunction; // update function
		}
		if (type != ItemGroup) { // we are adding an item to an exising group
			group->itemList = new ItemList{item, group->itemList};
			group->itemCount++;
		}
		return group;
	}
	DbgPrintln(F(" - insert new group in list: "), groupName);
	groupCount++;
	return _groupList = new Group {groupName, item, groupType, groupFunction, nullptr, (type == ItemNull) ? (uint8_t)1 : (uint8_t)0, 
		(type == ItemNull) ? new ItemList{item, nullptr} : nullptr, _groupList};
}

FORCE_INLINE OpenHab::Group *OpenHab::addItemToGroup(const char *groupName, Item *item, JsonObject obj) {
	DbgPrint(F("addItemToGroup adding item named: "), item->name);
	DbgPrintln(F(" - to group: "), groupName);
	return newGroup(groupName, item, obj, ItemNull); // create or get group
}

void OpenHab::GenSitemap(const JsonVariant prototype, TopLevelSitemap *sitemap, size_t uriBaseLen) {
	if (prototype.is<JsonObject>()) {
		const JsonObject& obj = prototype;
		for (const JsonPair pair : obj) {
			const char *key = pair.key().c_str();
			if (!strcmp_P(key, PSTR("link"))) { // Sitemap
				const char* link = pair.value().as<char*>();
				obj[pair.key()] = link + uriBaseLen;
			} else 
			//DbgPrint(F(" - key: "), key); DbgPrint(F(" - value: "), pair.value().as<const char *>()); DbgPrintln(F(" - free mem: "), ESP.getFreeHeap());
			if (!strcmp_P(key, PSTR("item"))) {// Items
				JsonObject itemObj = pair.value().as<JsonObject>();
				const char *name = itemObj[F("name")];
				const char *state = itemObj[F("state")];
				itemObj[F("state")] = "";	// we have copied state, discard it in JSON
				const char *transformedState = itemObj[F("transformedState")];
				if (transformedState) itemObj[F("transformedState")] = ""; // we have copied transformed state, discard it in JSON
				JsonObject stateObj = itemObj[F("stateDescription")];

				if (Item *item = getItem(name)) {	// Test if item has already been created
					item->referenceCount++; // New reference to existing item
					if (stateObj) itemObj.remove(F("stateDescription"));	// We have it still in master item
					if (item->labelFormat) obj[F("label")] = ""; // Discard formatted label for widget in Json, we have it in master
					DbgPrintln(F(" - referenceCount: "), item->referenceCount);
				} else {  // New item
					itemCount++;	// Increase global count of items
					const char *label = obj[F("label")];
					ItemType itemType = getItemType(itemObj[F("type")]);
					DbgPrint(F(" - id: "), itemCount);
					DbgPrintln(F(" - name: "), name);

					const char *pattern = nullptr;
					if (stateObj) {
						pattern = (transformedState) ? "%s" : stateObj[F("pattern")].as<const char *>();
						JsonArray options = stateObj[F("options")];
						if (options.size() > 0) {
							for (JsonVariant option : options)
								if (!strcmp(option[F("value")], state))
									state = option[F("label")];
							//DbgPrintln(F("options state: "), state);
						} else itemObj.remove(F("stateDescription")); //unless we have 'options' we no longer need statedesciption
					}
					const char *formattedLabel = nullptr;
					if (pattern) { // we have a formatted label
						formattedLabel = genFormattedLabel(label, pattern, state);
						if (itemType == ItemDateTime)
							convDateTimeJavaToC((char *) formattedLabel); // convert Java label format to C/C++ strftime format
						obj[F("label")] = ""; // Discard formatted label for widget in Json
					}
					Group *group = (itemType == ItemGroup ) ? newGroup(name, nullptr, itemObj, ItemGroup) : nullptr;
					_itemList = new Item{strdup(name), itemType, 0, 255, strcmp_P(state, PSTR("NULL")) ? strdup(state) : nullptr, 
						(formattedLabel) ? strdup(formattedLabel) : nullptr, group, _itemList};

					JsonArray groupNames = itemObj[F("groupNames")];
					if (groupNames.size() > 0)
						for (JsonVariant groupName : groupNames)
							addItemToGroup(groupName, _itemList, itemObj);
				}
			}
			yield();  // avoid Soft WDT reset
			GenSitemap(pair.value().as<JsonObject>(), sitemap, uriBaseLen); //, pair.key);
			for (auto arr : pair.value().as<JsonArray>()) {
				GenSitemap(arr.as<JsonVariant>(), sitemap, uriBaseLen); //, pair.key);
			}
		}
	} else if (prototype.is<JsonArray>()) {
		const JsonArray& arr = prototype;
		for (const auto& elem : arr) GenSitemap(elem.as<JsonVariant>(), sitemap, uriBaseLen); //, parent);
	}
}

void OpenHab::GetSitemap(const char *sitemap, String uriBase) {
	WiFiClient client;
	HTTPClient httpClient;  //Declare an object of class HTTPClient
	String uri = uriBase;
	uri += F("/rest/sitemaps/");
	uri += sitemap;
	httpClient.begin(client, uri);
	DbgPrint(F("GenConfig - uri: "), uri);
	int httpCode = httpClient.GET();                  //Send the request
	DbgPrintln(F(" - http code: "), httpCode);
	if (httpCode > 0) { //Check the returning code
		if (!SPIFFS.begin())
			Serial.println(F("Error mounting the file system"));
		SPIFFS.format();			
		File wfile = SPIFFS.open(F("/conf/sitemap.tmp"), "w");
		httpClient.writeToStream(&wfile);
		DbgPrintln(F(" - http get completed"));
		wfile.close();
	    httpClient.end();		//Close connection
		delay(5000);
	} else httpClient.end();		//Close connection
}

void OpenHab::GenConfig(const char *OpenHabServer, const int port, const char *sitemap) {

	String uriBase = F("http://");
	uriBase += OpenHabServer;
	uriBase += F(":");
	uriBase += port;
	// Get sitemap from full OpenHab 2.X server and write to SPIFFS in a buffered way
	GetSitemap(sitemap, uriBase);
	DbgPrintln(F(" - free mem after GetSitemap: "), ESP.getFreeHeap());
	yield();

	// Read sitemap as JsonObject from file
	const char *fileName = PSTR("/conf/sitemap.tmp");
	_topLevelSitemapList = new TopLevelSitemap{fileName, getJsonDocFromFile(fileName), nullptr};
	SPIFFS.end();
	DbgPrintln(F(" - free mem after new TopLevelSitemap: "), ESP.getFreeHeap());
	yield();

	// Adapt the sitemap to conserve memory
	GenSitemap(_topLevelSitemapList->jsonDoc.as<JsonObject>(), _topLevelSitemapList, uriBase.length());
	DbgPrintln(F(" - free mem ater GenSitemap: "), ESP.getFreeHeap());
	yield();

	// Print out the generated sitemap Json Object
	Serial.println(F("Copy the following line (JSON string) to data/conf/<your sitemap name> ---------------------------- "));
	BufferedPrint<HardwareSerial, 512> print(Serial);
	serializeJson(_topLevelSitemapList->jsonDoc, print);
	print.flush();
	Serial.println();
	Serial.println(F("----------------------------- "));
 	DbgPrintln(F("free heap memory: "), ESP.getFreeHeap());
	yield();
 	
	// Create an array of pointers to list of Items
	DbgPrintln(F("item count: "), itemCount);
	Item **itemList = new Item*[itemCount];
	
	auto getItemIdx = [&](const char *name) {
		uint8_t middle, first = 0, last = itemCount;
		do {
			middle = (first + last) >> 1;
			int cmp = strcmp(itemList[middle]->name, name);
			if (cmp == 0) return middle;
			else if (cmp < 0) first = middle + 1;
			else last = middle - 1;
		} while (first <= last);
		return (uint8_t) 255;		
	};

	Item *itemPtr = _itemList;
	for (unsigned int i = 0; i < itemCount; i++, itemPtr = itemPtr->next) {
		itemList[i] = itemPtr;
	}
 	DbgPrintln(F("free heap memory: "), ESP.getFreeHeap());
	// Bubble sort Items
	unsigned int n = 1;
	while (n < itemCount) {
		if (strcmp(itemList[n]->name, itemList[n - 1]->name) < 0) {
			Item *item = itemList[n];
			itemList[n] = itemList[n - 1];
			itemList[n - 1] = item;
			if (n > 1) n--;
		} else n++;
	}
	yield();

	// Create an array of pointers to list of Groups
	DbgPrintln(F("group count: "), groupCount);
	Group **groupList = new Group*[groupCount];
	groupCount = 0;
	for (n = 0; n < itemCount; n++) {
		if (itemList[n]->type == ItemGroup) {
			groupList[groupCount] = itemList[n]->group;
			itemList[n]->groupIdx = groupCount++;
		}
	}

	// Finally, write out the generated item, itemState and group list
	String items = F("OpenHab::Item items[] PROGMEM = {");
	for (unsigned int i = 0; i < itemCount; ) {
		items += F("{\"");
		items += itemList[i]->name;
		items += F("\", ");
		items += ItemTypeString[itemList[i]->type];
		items += F(", -1, ");
		items += itemList[i]->groupIdx;
		items += F(", ");
		const char *state = itemList[i]->state;
		if (state) {	// Non-empty state
			items += F("\"");
			items += state;
			items += F("\", ");
		} else switch (itemList[i]->type ) { // Empty state -> make "" or "0"
			case ItemContact:
			case ItemString:
			case ItemSwitch:
			case ItemGroup:
			case ItemDateTime:
				items += F("\"\", "); break;
			case ItemNumber:
			case ItemDimmer:
				items += F("\"0\", "); break;
				default:;
		}	 
		const char *labelFormat = itemList[i]->labelFormat;
		if (labelFormat) {
			items += F("\"");
			items += labelFormat;
			items += F("\"}");		
		} else items += F("nullptr}");
		if (++i == itemCount) items += "};";
		else items += ", ";
	}

	String itemState = F("OpenHab::ItemState itemStates[");
	itemState += itemCount;
	itemState += "];";

	String groups = F("OpenHab::Group groups[] = {");
	for (unsigned int i = 0; i < groupCount; ) {
		groups += "{";
		//groups += groupList[i]->name;
		//groups += ", ";		
		groups += ItemTypeString[groupList[i]->type];
		groups += F(", (GroupFunction) ");
		groups += groupList[i]->function;
		groups += F(", new uint8_t[");
		groups += groupList[i]->itemCount;
		groups += F("]{");
		ItemList *member = groupList[i]->itemList;
		while (member) {
			groups += (uint8_t) getItemIdx(member->item->name);
			member = member->next;
			if (member) groups += ", ";
		}
		groups += F("}, ");
		groups += groupList[i]->itemCount;
		if (++i == groupCount) groups += F("}};");
		else groups += F("}, ");
	}	
	Serial.println(F("Copy the following lines to src/main.cpp ---------------------------- "));
	Serial.println();
	Serial.printf_P(PSTR("uint8_t itemCount = %d;\n"), itemCount); // max 255 items on ESP8266
	Serial.println(itemState);
	Serial.println(items);
	Serial.printf_P(PSTR("uint8_t groupCount = %d;\n"), groupCount); // max 255 items on ESP8266
	Serial.println(groups);
	Serial.println();
	Serial.println(F("----------------------------- "));
}
#else

// Start the web server, handle all requests in a single function to save memory
void OpenHab::StartServer() { //
	//_server.on(FPSTRREF("/rest/items"), std::bind(&OpenHab::handleItems, this));
	//_server.on(F("/rest/sitemaps/events/subscribe"), std::bind(&OpenHab::handleSubscribe, this));
	//_server.on(FPSTRREF("/rest/services"), [this]() { SendFile(F("/conf/services.cfg")); });  //std::bind(&OpenHab::handleServices, this))
	//_server.on(FPSTRREF("/rest"), [this]() { SendFile(F("/conf/rest")); });  //std::bind(&OpenHab::handleServices, this))
	//_server.on(F("/icon"), [this]() { SendFile(_server.uri() + getContentTypeExt(IMAGE_PNG), true, IMAGE_PNG); }, false);

	//_server.on(FPSTRREF("/rest/sitemaps"), std::bind(&OpenHab::handleSitemaps, this, _sitemapList));
	_server.onNotFound(std::bind(&OpenHab::handleAll, this));
	_server.begin();
	//_SSEserver.onNotFound(std::bind(&OpenHab::SSEHandler, this));
	//_SSEserver.onNotFound(std::bind(&OpenHab::handleNotFound, this, _SSEserver));
	//auto handleNotFoundBind = std::bind(static_cast<void(OpenHab::*)(ESP8266WebServer &)>(&OpenHab::handleNotFound), &_SSEserver, *_SSEserver);
	//_SSEserver.onNotFound(handleNotFoundBind);
	_SSEserver.onNotFound(std::bind(&OpenHab::handleSSENotFound, this));
	//_SSEserver.keepCurrentClient(true);
	_SSEserver.begin();
	//using namespace std::placeholders;
	//_SSEserver.onEvent(std::bind(&OpenHab::SSESocketEvent, this, _1, _2, _3, _4)); 
}

OpenHab::Sitemap *OpenHab::GetSitemapsFromFS() {
	DbgPrintln(F("OpenHab::GetSitemapsFromFS"));
	Sitemap *sitemapList = nullptr;
	DbgPrintln(F("free heap memory: "), ESP.getFreeHeap());
	Dir dir = SPIFFS.openDir(F("/conf/sitemaps"));
	while (dir.next()) {
		String fileName = dir.fileName(); 
		sitemapList = new Sitemap{fileName, getJsonDocFromFile(fileName), nullptr}; //, topLevelSitemapList 
		registerLinkHandlers(sitemapList->jsonDoc.as<JsonObject>(), "", sitemapList);
		break; //At this moment, allow only one sitemap
	}
	DbgPrintln(F("free heap memory @exit: "), ESP.getFreeHeap());
	return sitemapList;
}

void OpenHab::SendJson(JsonVariant obj) {
	int size = measureJson(obj);
	DbgPrintln(F("OpenHab::SendJson "), size);	
	_server.setContentLength(size);
	_server.send_P(200, getContentTypeStr(APP_JSON), NULL);
	_print.client(_server.client());
	serializeJson(obj, _print);
	_print.stop(_server.client());
 	DbgPrintln(F("free heap memory: "), ESP.getFreeHeap());
}

void OpenHab::SendFile(String fname, ContentType contentType, const char *pre, const char *post) {
	DbgPrintln(F("OpenHab::SendFile "), fname);
	char buf[512];
	if (SPIFFS.exists(fname)) {
		File f = SPIFFS.open(fname, "r");
		size_t sz = f.size();
		//DbgPrintln(F("file size "), sz);
		_server.setContentLength((pre || post) ? CONTENT_LENGTH_UNKNOWN : sz);
	 	_server.send_P(200, getContentTypeStr(contentType), NULL);
		if (pre) _server.sendContent_P(pre);
		while (sz > 0) {
			size_t len = std::min((size_t) sizeof(buf), sz);
			//DbgPrintln(F("len "), len);
			f.readBytes(buf, len);
			_server.sendContent((const char*)buf, len);
			sz -= len; 
		}
		if (post) {
			_server.sendContent_P(post);
			_server.sendContent_P(PSTR(""));
		}
		f.close();
	} else DbgPrintln(F("File not found"));
}

void OpenHab::handleSitemap(const char *uri) {
	//static int handleCount = 0;
	if (strcmp_P(uri, PSTR("events/subscribe")) == 0)
		return handleSubscribe();	//this is a sitemap event registration
	//if ((handleCount < 10) || ((handleCount % 100) == 99)) {
		DbgPrintln(F("OpenHab::handleSitemap - "), uri);
	//	DbgPrintln(F("method: "), HTTPMethodStr[_server.method()]);
	//}
	//while (*uri++ != '/');	// Skip sitemap name
	Sitemap *sitemap = _sitemapList;
	//while (topLevelSitemap) {
		Page *page = sitemap->pageList;
		while (page) {
			DbgPrintln(F("page link: "), page->pageId);
			if (strcmp(page->pageId, uri) == 0)
				return SendJson(page->obj);
			page = page->next;
		}
	//	topLevelSitemap = topLevelSitemap->next;
	//}
	handleNotFound(_server); 
}

void OpenHab::handleItem(const char *uri) {
	DbgPrintln(F("OpenHab::handleItem"));
	uint8_t itemIdx = getItemIdx(uri);
	if (isValidItemIndex(itemIdx)) {
		ItemState &itemState = itemStates[itemIdx];
		JsonVariant obj = itemState.obj;
		DbgPrintln(F("Item found - free heap memory: "), ESP.getFreeHeap());
		if (_server.method() == HTTP_GET) return SendJson(obj);
		else if (_server.method() == HTTP_POST) {
			DbgPrintRequest(_server, "handleItem - POST request: ");
			if (_server.hasArg(F("plain"))) { //Check if body received as plain argument
				//if (!strcmp(objType, "Switch"))
				const char *state = _server.arg(F("plain")).c_str();
				//if (strcmp(state, itemState.state)) { // state (type char *) has changed 
				setState(itemIdx, state);				
				DbgPrintln(F("new state: "), itemState.state);
				//}
				DbgPrintln(F("free heap memory: "), ESP.getFreeHeap());
			}
			_server.send_P(200, PSTR("text/plain"), NULL);
		}
		DbgPrintln(F("free heap memory @exit: "), ESP.getFreeHeap());
		return;
	}
	handleNotFound(_server);
}

// While the data structures allow for multiple sitemaps (sitemap list), only one is supported for now
ICACHE_FLASH_ATTR void OpenHab::handleSitemaps(Sitemap *sitemap) {
	DbgPrintln(F("OpenHab::handleSiteMaps"));
	SendFile(sitemap->name, APP_JSON, PSTR("["), PSTR("]"));
	//if (sitemap) _server.sendContent_P(PSTR(","));
}

ICACHE_FLASH_ATTR void OpenHab::handleSubscribe() {
	DbgPrintln(F("OpenHab::handleSubscribe"));
	//DbgPrintRequest(F("subscribe: "));
	DynamicJsonDocument	jsonDoc = getJsonDocFromFile(F("/conf/subscribe"));
	IPAddress clientIP = _server.client().remoteIP();
	String SSEurl = F("http://");
	SSEurl += _espIP.toString();
	SSEurl += F(":");
	SSEurl += _port + 1;
	size_t offset = SSEurl.length();
	SSEurl += F("/rest/sitemaps/events/");

	Subscription *subscription = _subscription;
	while (subscription && (subscription->clientIP != (uint32_t) clientIP))
		subscription = subscription->next;
	if (!subscription) {
		Serial.printf_P(PSTR("new client IP %x %s\n"), (uint32_t) clientIP, clientIP.toString().c_str());	
		byte uuid[16]; 
		ESP8266TrueRandom.uuid(uuid);
		subscription = new Subscription{(uint32_t) clientIP, _server.client(), _subscription, ESP8266TrueRandom.uuidToString(uuid)};
		//memcpy((void *) subscription->uuidStr, (const void *)uuidString.c_str(), 37);
		SSEurl += subscription->uuidStr;
		DbgPrintln("new SSE location registration: ", SSEurl.substring(offset));
		_SSEserver.on(SSEurl.substring(offset), std::bind(&OpenHab::SSEHandler, this));
		_subscription = subscription;
	} else SSEurl += subscription->uuidStr;
	//memcpy((void *)(uuidStr + sizeof("/rest/sitemaps/events")), subscription->uuidStr, 36); //patch UUID
	JsonObject context = jsonDoc.as<JsonObject>()[F("context")];
	JsonArray location = context[F("headers")][F("Location")];
	location[0] = (const char *)(SSEurl.c_str());
	SendJson(jsonDoc.as<JsonVariant>());
	jsonDoc.clear();
	DbgPrintln(F("free heap memory @exit: "), ESP.getFreeHeap());
}

void OpenHab::handleIcon(const char *uri) {
	auto getIconType = [&](const char *type) {
		for (uint8_t n = 0; n < 4; n++)
			if (strcmp_P(type, ContentTypeArg[n]) == 0) return (ContentType) n;
		return (ContentType) 4;
	};

	DbgPrintRequest(_server, F("icon"));
	String state = _server.arg("state");
	state.toLowerCase();
	bool anyformat = (strcmp_P(_server.arg("anyFormat").c_str(), PSTR("true")) == 0);
	ContentType type = (anyformat) ? IMAGE_DEFAULT : getIconType(_server.arg("format").c_str());
	const char *ext = getContentTypeExt(type);
	String fileName = uri;
	fileName += "-";
	fileName += state;
	fileName += ext;
	if (SPIFFS.exists(fileName)) return SendFile(fileName.c_str(), type);
	fileName = uri;
	fileName += ext;
	SendFile(fileName.c_str(), type);
}

ICACHE_FLASH_ATTR void OpenHab::handleNotFound(ESP8266WebServer &server) {
	DbgPrintln(F("OpenHab::handleNotFound: "), server.uri()); // At this point we don't understand the request
	DbgPrintRequest(server, F("handleNotFound"));
	server.send(404, F("text/plain"), server.responseCodeToString(404));
}

ICACHE_FLASH_ATTR void OpenHab::handleSSENotFound() {
	handleNotFound(_SSEserver);
}

// ESP webserver does not support wildcards, process image/icon requests here
void OpenHab::handleAll() {
	const char* uri = _server.uri().c_str();
	DbgPrintln(F("OpenHab::handleAll: "), uri);
	DbgPrintln(F("free heap memory @entry: "), ESP.getFreeHeap());
	if (strncmp_P(uri, PSTR("/icon/"), 6) == 0)
		return handleIcon(uri);
	if (strncmp_P(uri, PSTR("/rest/items/"), 12) == 0)
	//if (uri.startsWith(F("/rest/items/")))
		return handleItem(uri + 12);
	if (strncmp_P(uri, PSTR("/rest/sitemaps/"), 15) == 0)
		return (handleSitemap(uri + sizeof("/rest/sitemaps")));
	if (strcmp_P(uri, PSTR("/rest/sitemaps")) == 0)
		return handleSitemaps(_sitemapList);
	if (strcmp_P(uri, PSTR("/chart")) == 0)
		return SendFile(strcat_P((char *)uri, getContentTypeExt(IMAGE_PNG)), IMAGE_PNG);
	if (strcmp_P(uri, PSTR("/rest")) == 0)
		return SendFile(F("/conf/rest"));
	if ((strcmp_P(uri, PSTR("/rest/links")) == 0) || (strcmp_P(uri, PSTR("/rest/bindings")) == 0))
		return _server.send_P(200, PSTR("application/json"), PSTR("[]"));
	if (strcmp_P(uri, PSTR("/rest/services")) == 0)
		return SendFile(F("/conf/services.cfg"));
	handleNotFound(_server);
}

#endif